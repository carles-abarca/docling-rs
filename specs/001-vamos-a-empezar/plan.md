# Implementation Plan: Core Document Processing Library (MVP Phase 1)

**Branch**: `001-vamos-a-empezar` | **Date**: 2025-10-04 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/Users/carlesabarca/MyProjects/docling-rs/specs/001-vamos-a-empezar/spec.md`

## Summary

Build a native Rust library for extracting structured text and metadata from common document formats (Markdown, HTML, CSV, DOCX) without Python dependencies. The library provides a unified `DoclingDocument` representation, format-specific backends, and a simple processing pipeline. This is Phase 1 MVP - library-only, no CLI.

## Technical Context

**Language/Version**: Rust 1.75+ (stable)
**Primary Dependencies**:
- `serde` + `serde_json` for serialization
- `pulldown-cmark` or `comrak` for Markdown parsing
- `scraper` for HTML parsing
- `csv` for CSV parsing
- `docx-rs` or equivalent for DOCX parsing
- `infer` or `tree_magic` for file type detection

**Storage**: File system (no database)
**Testing**: cargo test, cargo clippy, cargo fmt
**Target Platform**: Windows and macOS (cross-platform)
**Project Type**: single (library crate)
**Performance Goals**: <100ms for small documents (<1MB)
**Constraints**: No Python dependencies, no unsafe code (unless justified), library-only (no CLI)
**Scale/Scope**: MVP with 4 document formats, ~10-15 core types, foundational architecture

## Constitution Check
*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Initial Constitution Check

**I. Library-First Architecture** ✅
- Feature is library-only (no CLI in Phase 1)
- Clear module boundaries: backends, pipeline, data models
- Self-contained, independently testable

**II. CLI Interface Contract** ⚠️ DEFERRED
- CLI explicitly excluded from Phase 1 per spec
- Will be addressed in future phase if needed

**III. Test-Driven Development** ✅
- TDD workflow will be followed during implementation
- Tests written before implementation per constitution

**IV. Integration & Contract Testing** ✅
- Contract tests planned for backend trait implementations
- Integration tests planned for each format

**V. Rust Best Practices** ✅
- Idiomatic Rust patterns
- Clippy lints enforced
- No unsafe code
- Result types for error handling
- Rustdoc for all public APIs

**VI. Cross-Platform Compatibility** ✅
- Windows and macOS support required
- Platform-agnostic file paths (std::path)
- Line ending handling

**VII. Native Rust Dependencies** ✅
- All dependencies are native Rust crates
- No Python bindings
- Documented mapping from Python docling dependencies

**Constitution Compliance**: PASS (CLI deferred as per spec)

## Project Structure

### Documentation (this feature)
```
specs/001-vamos-a-empezar/
├── plan.md              # This file
├── research.md          # Phase 0: Dependency research
├── data-model.md        # Phase 1: Data structures
├── quickstart.md        # Phase 1: Usage examples
├── contracts/           # Phase 1: Backend contracts
│   ├── backend_trait.md
│   ├── markdown_backend.md
│   ├── html_backend.md
│   ├── csv_backend.md
│   └── docx_backend.md
└── tasks.md             # Phase 2: Generated by /tasks command
```

### Source Code (repository root)
```
docling-rs/
├── Cargo.toml
├── src/
│   ├── lib.rs                    # Public API exports
│   ├── datamodel/
│   │   ├── mod.rs
│   │   ├── document.rs           # DoclingDocument
│   │   ├── input.rs              # InputDocument
│   │   ├── result.rs             # ConversionResult
│   │   ├── node.rs               # NodeItem (hierarchical)
│   │   ├── text.rs               # TextItem
│   │   └── table.rs              # TableData
│   ├── backend/
│   │   ├── mod.rs
│   │   ├── traits.rs             # Backend, DeclarativeBackend
│   │   ├── markdown.rs           # MarkdownBackend
│   │   ├── html.rs               # HtmlBackend
│   │   ├── csv.rs                # CsvBackend
│   │   └── docx.rs               # DocxBackend
│   ├── pipeline/
│   │   ├── mod.rs
│   │   ├── traits.rs             # Pipeline trait
│   │   └── simple.rs             # SimplePipeline
│   ├── converter.rs              # DocumentConverter
│   ├── error.rs                  # Error types
│   └── format.rs                 # Format detection
├── tests/
│   ├── contract/
│   │   ├── backend_markdown.rs
│   │   ├── backend_html.rs
│   │   ├── backend_csv.rs
│   │   └── backend_docx.rs
│   ├── integration/
│   │   ├── markdown_conversion.rs
│   │   ├── html_conversion.rs
│   │   ├── csv_conversion.rs
│   │   └── docx_conversion.rs
│   └── fixtures/
│       ├── sample.md
│       ├── sample.html
│       ├── sample.csv
│       └── sample.docx
└── examples/
    └── basic_conversion.rs
```

**Structure Decision**: Single project (library crate) as this is Phase 1 MVP focusing on core functionality. No CLI, web, or mobile components.

## Phase 0: Outline & Research

### Research Tasks

1. **Rust Markdown Parsing**
   - Decision: `pulldown-cmark` (CommonMark compliant, widely used)
   - Rationale: Pure Rust, zero-copy parsing, mature library
   - Alternatives: `comrak` (GFM support), `markdown` crate

2. **Rust HTML Parsing**
   - Decision: `scraper` (built on html5ever)
   - Rationale: CSS selector support, standards-compliant, good for semantic extraction
   - Alternatives: `html5ever` directly, `select.rs`

3. **Rust CSV Parsing**
   - Decision: `csv` crate by BurntSushi
   - Rationale: Industry standard, excellent performance, flexible API
   - Alternatives: `polars` (overkill for simple parsing)

4. **Rust DOCX Parsing**
   - Decision: Research needed - `docx-rs` or `docx` crate
   - Rationale: Need to verify: feature completeness, maintenance status, API ergonomics
   - Alternatives: Parse XML manually using `quick-xml`

5. **File Type Detection**
   - Decision: `infer` crate
   - Rationale: Fast magic number detection, minimal dependencies
   - Alternatives: `tree_magic`, manual extension checking

6. **Serialization**
   - Decision: `serde` + `serde_json`
   - Rationale: De facto standard, extensive ecosystem
   - Alternatives: None suitable

### Research Output Location
`/Users/carlesabarca/MyProjects/docling-rs/specs/001-vamos-a-empezar/research.md`

## Phase 1: Design & Contracts

### Data Model Design

**Core Types** (to be detailed in `data-model.md`):

1. **DoclingDocument**
   ```
   - metadata: DocumentMetadata (origin, format, page_count)
   - root: NodeItem (hierarchical root)
   - exports: to_json(), to_markdown()
   ```

2. **InputDocument**
   ```
   - file_info: PathBuf or Vec<u8>
   - format: InputFormat enum
   - backend: Box<dyn Backend>
   ```

3. **ConversionResult**
   ```
   - input: InputDocument
   - document: Option<DoclingDocument>
   - status: ConversionStatus (Success/Failure/Partial)
   - errors: Vec<ConversionError>
   - warnings: Vec<String>
   ```

4. **NodeItem** (hierarchical)
   ```
   - node_type: NodeType (Section/Paragraph/List/Table/Heading)
   - children: Vec<NodeItem>
   - text: Option<TextItem>
   - table: Option<TableData>
   ```

5. **TextItem**
   ```
   - content: String
   - formatting: Option<Formatting> (bold, italic, etc.)
   ```

6. **TableData**
   ```
   - headers: Vec<String>
   - rows: Vec<Vec<String>>
   ```

### Backend Contracts

**Backend Trait** (contract in `contracts/backend_trait.md`):
```rust
pub trait Backend {
    fn is_valid(&self) -> bool;
    fn supported_formats() -> &'static [InputFormat];
    fn convert(&self, input: &InputDocument) -> Result<DoclingDocument, ConversionError>;
}

pub trait DeclarativeBackend: Backend {
    // Marker trait for backends that convert directly
}
```

**Format-Specific Contracts**:
- `contracts/markdown_backend.md`: Markdown → DoclingDocument conversion rules
- `contracts/html_backend.md`: HTML → DoclingDocument semantic mapping
- `contracts/csv_backend.md`: CSV → TableData structure rules
- `contracts/docx_backend.md`: DOCX → DoclingDocument with formatting

### Pipeline Contract

**SimplePipeline** (to be detailed):
```rust
pub trait Pipeline {
    fn execute(&self, input: InputDocument) -> ConversionResult;
}

// SimplePipeline implementation:
// 1. Build: Call backend.convert()
// 2. Assemble: Organize hierarchy (already done by declarative backends)
// 3. Enrich: Add metadata, validate structure
```

### Integration Tests

**Quickstart Test Scenarios** (in `quickstart.md`):
1. Convert Markdown file with headings and lists
2. Convert HTML file with tables and semantic markup
3. Convert CSV file to tabular structure
4. Convert DOCX file with mixed content
5. Auto-detect format and convert
6. Export DoclingDocument to JSON
7. Export DoclingDocument to Markdown

### Agent Context File

Will run: `.specify/scripts/bash/update-agent-context.sh claude`

This will create/update `CLAUDE.md` in repository root with:
- Recent tech decisions (dependencies chosen)
- Project structure
- Key types and traits
- Development workflow notes

**Output Location**: `/Users/carlesabarca/MyProjects/docling-rs/CLAUDE.md`

## Phase 1 Constitution Re-Check

After Phase 1 design completion, re-evaluate:

**Library-First** ✅ - Clear module boundaries maintained
**TDD** ✅ - Contract tests defined before implementation
**Integration Testing** ✅ - Contract tests for each backend planned
**Rust Best Practices** ✅ - Idiomatic trait design, error handling
**Cross-Platform** ✅ - No platform-specific dependencies identified
**Native Rust** ✅ - All chosen dependencies are pure Rust

**Post-Design Constitution Check**: PASS

## Phase 2: Task Planning Approach
*This section describes what /tasks will do - NOT executed during /plan*

**Task Generation Strategy**:
1. Load `data-model.md` → Extract entities → Create type definition tasks
2. Load backend contracts → Create backend implementation tasks
3. Load quickstart scenarios → Create integration test tasks
4. Order: Types → Traits → Tests → Implementations

**Task Categories**:
- **Setup** (3-5 tasks): Cargo.toml, project structure, CI config
- **Data Models** (6-8 tasks): One task per core type
- **Backend Traits** (2-3 tasks): Backend trait definitions
- **Backend Tests** (4 tasks): Contract tests (one per format)
- **Backend Implementation** (4 tasks): Implementation (one per format)
- **Pipeline** (3-4 tasks): Pipeline trait, SimplePipeline, tests
- **Converter** (3-4 tasks): DocumentConverter, format detection, tests
- **Integration** (5-6 tasks): End-to-end tests per format
- **Documentation** (2-3 tasks): Examples, README, rustdoc

**Estimated Total**: 30-35 tasks

**Parallelization**:
- [P] tasks: Different files/modules (can run in parallel)
- Sequential: Same file or dependent types

**IMPORTANT**: Phase 2 is executed by `/tasks` command, NOT by `/plan`

## Complexity Tracking

No constitutional violations identified. All complexity is justified:

| Design Decision | Justification |
|----------------|---------------|
| Multiple backend traits | Needed for format-specific conversion strategies |
| Pipeline abstraction | Future extensibility (Phase 2 chunking, Phase 3 PDF) |
| Hierarchical NodeItem | Required for preserving document structure |

## Progress Tracking

**Phase Status**:
- [x] Phase 0: Research complete
- [x] Phase 1: Design complete
- [x] Phase 2: Task planning approach described
- [ ] Phase 3: Tasks generation (awaiting /tasks command)
- [ ] Phase 4: Implementation
- [ ] Phase 5: Validation

**Gate Status**:
- [x] Initial Constitution Check: PASS (CLI deferred)
- [x] Post-Design Constitution Check: PASS
- [x] All technical unknowns resolved
- [x] Complexity justified

---
*Based on Constitution v1.2.0 - See `/memory/constitution.md`*
